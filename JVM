内存结构：
1.程序计数器：当前线程所执行的字节码的行号指示器。虚拟机是多线程切换的，所以为了在切换回线程能准确回到之前的位置，每个线程都需要一个指示器，没有规定outofmemory情况的区域。
2.JAVA虚拟机栈：线程私有。每个方法执行时都会创建一个栈帧存储局部变量表，操作数栈，动态链接，方法出口等信息。栈中的局部变量表：各种基本数据类型，对象引用类型，编译器完成内存分配。
3.本地方法栈：找到native方法。
4.堆：物理上不连续，逻辑连续，存储对象实例，分为新生代和老年代。
5.方法区：已被加载的类信息，常量，静态变量，即时编译器编译后的代码等。
6.运行时常量池。
7.直接内存。

对象的创建：
先检查常量池有没有类的符号的引用，类加载检查通过后，分配内存，可在类加载完成后完全确定内存。
然后将分配到的内存空间初始化为0值，保证了对象实例字段不被赋值就可以使用。然后执行Init方法。

对象的内存布局：
对象头：存储运行时数据和类型指针，确定对象是哪个类的实例，如果是数组，还要记录数组长度。
实例数据部分：对象的各种信息。
填充部分：对齐。

对象的访问：
句柄或指针。

Java堆处理内存泄漏：
查看GC Roots的引用链，找到垃圾回收器不能回收的原因，定位代码。
内存溢出：
看看堆参数能不能再调大，看看有没有某些对象生命周期过长，持有状态过长的情况。看看堆参数还能不能调大。

虚拟机栈和本地方法溢出：
可以尝试减少虚拟机栈的内存。
